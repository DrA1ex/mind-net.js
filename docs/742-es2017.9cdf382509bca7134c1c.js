(self.webpackChunkneural_network=self.webpackChunkneural_network||[]).push([[742],{5307:function(t,e,s){"use strict";s.d(e,{hl:function(){return r},ZN:function(){return n},fe:function(){return h},B5:function(){return o},lu:function(){return a},BU:function(){return l},W0:function(){return c},bM:function(){return p},MX:function(){return m},JG:function(){return f},KM:function(){return d},Kk:function(){return g}});var i=s(8992);function r(t,e){return Array.from(i.UI(i.w6(0,e),t))}function n(t,e,s){const i=Math.min(t.length,e.length);for(let r=0;r<i;++r)t[r]=s(t[r],e[r])}function h(t,e,s,i){const r=Math.min(t.length,e.length),n=i||new Array(r);for(let h=0;h<r;++h)n[h]=s(t[h],e[h]);return n}function o(t,e,s){const i=t.length,r=s||new Array(i);for(let n=0;n<i;++n)r[n]=e(t[n],n);return r}function a(t,e,s){return h(t,e,(t,e)=>t-e,s)}function l(t,e){n(t,e,(t,e)=>t+e)}function c(t,e){return h(t,e,(t,e)=>t*e,t)}function u(t,e){const s=Math.min(t.length,e.length);let i=0,r=0;for(let n=0;n<s;++n){const s=t[n]*e[n]-r,h=i+s;r=h-i-s,i=h}return i}function p(t){return function(t,e){return r(()=>0,e)}(0,t)}function m(t,e=0,s=1){const i=s-e;return r(()=>e+Math.random()*i,t)}function f(t){return[...t]}function d(t,e,s){const i=t.length,r=s||new Array(i);for(let n=0;n<i;n++)r[n]=u(t[n],e);return r}function g(t,e){const s=new Array(t[0].length),i=Math.min(t.length,e.length);for(let r=0;r<s.length;++r){let n=0,h=0;for(let s=0;s<i;s++){const i=t[s][r]*e[s]-h,o=n+i;h=o-n-i,n=o}s[r]=n}return s}},6851:function(t,e,s){"use strict";s.d(e,{Z:function(){return c}});var i=s(5307);const r={sgd:class{constructor(t=.01){this.lr=t,this.description=`sgd(lr: ${this.lr})`}step(t,e,s,r){return i.fe(e,s,(e,s)=>t.activation.moment(e)*s*this.lr)}},nesterov:class{constructor(t=.9,e=.01){this.cache=new Map,this.lr=e,this.beta=t,this.description=`nesterov(beta: ${this.beta}, lr: ${this.lr})`}step(t,e,s,r){this.cache.has(t)||this.cache.set(t,{moments:i.bM(t.size),tmp1:i.bM(t.size)});const n=this.cache.get(t);return i.fe(e,n.moments,(e,s)=>t.activation.moment(e+s),n.tmp1),i.W0(n.tmp1,s),i.ZN(n.moments,n.tmp1,(t,e)=>this.beta*t+this.lr*e),n.moments}},adam:class{constructor(t=.9,e=.999,s=.005,i=1e-8){this.cache=new Map,this.lr=s,this.beta1=t,this.beta2=e,this.eps=i,this.description=`adam(beta1: ${t}, beta2: ${e}, lr: ${this.lr}, eps: ${i.toExponential()})`}step(t,e,s,r){this.cache.has(t)&&0!==r||this.cache.set(t,{moments:i.bM(t.size),velocities:i.bM(t.size),tmp1:i.bM(t.size),tmp2:i.bM(t.size)});const n=this.cache.get(t);return i.fe(e,s,(e,s)=>t.activation.moment(e)*s,n.tmp1),i.ZN(n.moments,n.tmp1,(t,e)=>t*this.beta1+(1-this.beta1)*e),i.ZN(n.velocities,n.tmp1,(t,e)=>t*this.beta2+(1-this.beta2)*e*e),i.ZN(n.tmp1,n.moments,(t,e)=>e/(1-Math.pow(this.beta1,r+1))),i.ZN(n.tmp2,n.velocities,(t,e)=>e/(1-Math.pow(this.beta2,r+1))),i.ZN(n.tmp1,n.tmp2,(t,e)=>t*this.lr/(Math.sqrt(e)+this.eps)),n.tmp1}},rmsprop:class{constructor(t=.9,e=.005,s=1e-8){this.cache=new Map,this.beta=t,this.lr=e,this.eps=s,this.description=`rmsprop(beta: ${t}, lr: ${this.lr}, eps: ${this.eps})`}step(t,e,s,r){this.cache.has(t)||this.cache.set(t,{velocities:i.bM(t.size),tmp1:i.bM(t.size)});const n=this.cache.get(t);return i.fe(e,s,(e,s)=>s*t.activation.moment(e),n.tmp1),i.ZN(n.velocities,n.tmp1,(t,e)=>this.beta*t+(1-this.beta)*e*e),i.ZN(n.tmp1,n.velocities,(t,e)=>this.lr/Math.sqrt(e+this.eps)*t),n.tmp1}}};class n{constructor(t=.01){this.alpha=t}value(t){return t>0?t:t*this.alpha}moment(t){return t>0?1:this.alpha}}const h={sigmoid:class{value(t){return 1/(1+Math.exp(-t))}moment(t){const e=this.value(t);return e*(1-e)}},relu:class{constructor(){this.leakyRelu=new n(0)}value(t){return this.leakyRelu.value(t)}moment(t){return this.leakyRelu.moment(t)}},leakyRelu:n,tanh:class{value(t){return Math.tanh(t)}moment(t){return 1-Math.pow(Math.tanh(t),2)}}},o={zero:function(t,e){return i.bM(t)},xavier:function(t,e){const s=Math.sqrt(6/(t+e));return i.MX(t,-s,s)},uniform:function(t,e){return i.MX(t,-1,1)}},a={Dense:class{constructor(t,e="sigmoid",s="xavier",i="zero"){if(this.prevSize=0,this.size=t,this.weight_initializer="string"==typeof s?o[s]:s,!this.weight_initializer)throw new Error(`Unknown weight initializer type ${s}`);if(this.bias_initializer="string"==typeof i?o[i]:i,!this.bias_initializer)throw new Error(`Unknown bias initializer type ${i}`);const r="string"==typeof e?h[e]:e;if(!r)throw new Error(`Unknown activation type ${e}`);this.activation="object"==typeof r?r:new r}build(t,e){this.prevSize=e,t>0?(this.weights=i.hl(()=>this.weight_initializer(this.prevSize,this.size),this.size),this.biases=this.bias_initializer(this.size,this.prevSize),this.values=i.bM(this.size)):(this.weights=[],this.biases=[],this.values=[])}step(t){return this.weights.length>0?(i.KM(this.weights,t,this.values),i.BU(this.values,this.biases),this.values):t}}};"undefined"!=typeof window&&window,"undefined"!=typeof self&&"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope&&self,"undefined"!=typeof global&&global;class l{constructor(){this.compiled=!1,this.epoch=0,this.trainable=[],this.layers=[],this.cache=new Map,this.modelByLayer=new Map,this.models=[]}addModel(t,e=!0){return this.models.push(t),this.trainable.push(e),this}compile(){if(!this.compiled){for(let t=0;t<this.models.length;t++){const e=this.models[t];if(t>0){const s=this.models[t-1],i=e.layers[0].size,r=s.layers[s.layers.length-1].size;if(i!==r)throw new Error(`Models in chain has different in-out sizes: ${r} != ${i}`)}let s;e.compile(),s=t>0?e.layers.slice(1):e.layers;for(const i of s)this.modelByLayer.set(i,[e,this.trainable[t]]),this.cache.set(i,new Array(i.size));this.layers.push(...s)}this.compiled=!0}}compute(t){if(!this.compiled)throw new Error("Model should be compiled before usage");let e=t;for(const s of this.models)e=s.compute(e);return e}train(t,e){if(!this.compiled)throw new Error("Model should be compiled before usage");const s=new Array(this.layers.length),r=new Array(this.layers.length);s[0]=t;for(let h=1;h<this.layers.length;h++){const t=this.layers[h];r[h]=t.step(s[h-1]),s[h]=i.B5(r[h],e=>t.activation.value(e),this.cache.get(t))}let n=i.lu(e,s[s.length-1]);for(let h=this.layers.length-1;h>0;h--){const t=this.layers[h],[e,o]=this.modelByLayer.get(t),a=e.optimizer.step(t,r[h],n,this.epoch);if(o){for(let e=0;e<t.size;e++)i.ZN(t.weights[e],s[h-1],(t,s)=>t+s*a[e]);i.ZN(t.biases,a,(t,e)=>t+e),h>1&&(n=i.Kk(t.weights,n))}else{const e=new Array(t.size);for(let r=0;r<t.size;r++)e[r]=i.fe(t.weights[r],s[h-1],(t,e)=>t+e*a[r]);n=i.Kk(e,n)}}this.epoch+=1}}var c={Activations:h,Initializers:o,Optimizers:r,Layers:a,Models:{Sequential:class{constructor(t="sgd"){this.compiled=!1,this.epoch=0,this.layers=[],this.cache=new Map;const e="string"==typeof t?r[t]:t;if(!e)throw new Error(`Unknown optimizer type ${e}`);this.optimizer="object"==typeof e?e:new e}addLayer(t){return this.layers.push(t),this}compile(){if(!this.compiled){for(let t=0;t<this.layers.length;t++){const e=this.layers[t];e.build(t,t>0?this.layers[t-1].size:0),this.cache.set(e,new Array(e.size))}this.compiled=!0}}compute(t){if(!this.compiled)throw new Error("Model should be compiled before usage");if(t.length!==this.layers[0].size)throw new Error(`Input matrix has different size. Expected size ${this.layers[0].size}, got ${t.length}`);let e=t;for(let s=1;s<this.layers.length;s++){const t=this.layers[s];e=i.B5(t.step(e),e=>t.activation.value(e),this.cache.get(t))}return e}train(t,e){if(!this.compiled)throw new Error("Model should be compiled before usage");if(t.length!==this.layers[0].size)throw new Error(`Input matrix has different size. Expected size ${this.layers[0].size}, got ${t.length}`);const s=this.layers[this.layers.length-1].size;if(e.length!==s)throw new Error(`Output matrix has different size. Expected size ${s}, got ${e.length}`);const r=new Array(this.layers.length),n=new Array(this.layers.length);r[0]=t;for(let o=1;o<this.layers.length;o++){const t=this.layers[o];n[o]=t.step(r[o-1]),r[o]=i.B5(n[o],e=>t.activation.value(e),this.cache.get(t))}let h=i.lu(e,r[r.length-1]);for(let o=this.layers.length-1;o>0;o--){const t=this.layers[o],e=this.optimizer.step(t,n[o],h,this.epoch);for(let s=0;s<t.size;s++)i.ZN(t.weights[s],r[o-1],(t,i)=>t+i*e[s]);i.ZN(t.biases,e,(t,e)=>t+e),o>1&&(h=i.Kk(t.weights,h))}this.epoch+=1}getSnapshot(){return{weights:this.layers.slice(1).map(t=>t.weights.map(t=>i.JG(t))),biases:this.layers.slice(1).map(t=>i.JG(t.biases))}}},Chain:class extends class{constructor(t,e){this.span=t,this.sourceSpan=e}toString(){return"AST"}}{constructor(t,e,s){super(t,e),this.expressions=s}visit(t,e=null){return t.visitChain(this,e)}},GAN:class{constructor(t,e){this.generator=t,this.discriminator=e,this.ganChain=new l,this.ganChain.addModel(t).addModel(e,!1).compile()}compute(t){return this.generator.compute(t)}train(t,e,s,i){this.discriminator.train(t,e);const r=this.generator.compute(s);this.discriminator.train(r,i),this.ganChain.train(s,e)}}}}},3515:function(t,e,s){"use strict";function i(t){const e=function(t){return[Number.parseInt(t.substr(1,2),16),Number.parseInt(t.substr(3,2),16),Number.parseInt(t.substr(5,2),16)]}(t);return 4278190080|e[2]<<16|e[1]<<8|e[0]}function r(t,e,s){const i=t>>16&255,r=t>>8&255,n=255&t;return((e>>16&255)-i)*(s=Math.max(0,Math.min(1,s)))+i<<16|((e>>8&255)-r)*s+r<<8|((255&e)-n)*s+n|4278190080}s.d(e,{h0:function(){return i},a4:function(){return r}})}}]);